From 5088f4319345cf76941be2a3cef0626f4b00a1b5 Mon Sep 17 00:00:00 2001
From: "arvind.m" <arvind.m@csa.iisc.ernet.in>
Date: Thu, 18 May 2017 12:36:44 +0530
Subject: [PATCH] add libpluto as an optimizer for polly

Signed-off-by: arvind.m <arvind.m@csa.iisc.ernet.in>
---
 CMakeLists.txt                      |  10 ++
 cmake/FindPluto.cmake               |  24 +++
 include/polly/Config/config.h.cmake |   1 +
 include/polly/LinkAllPasses.h       |  10 ++
 lib/CMakeLists.txt                  |   4 +
 lib/External/CMakeLists.txt         |  53 +++++--
 lib/Support/RegisterPasses.cpp      |  16 +-
 lib/Transform/Pluto.cpp             | 283 ++++++++++++++++++++++++++++++++++++
 8 files changed, 387 insertions(+), 14 deletions(-)
 create mode 100644 cmake/FindPluto.cmake
 create mode 100644 lib/Transform/Pluto.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index a748c22..33fe3ca 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -149,6 +149,16 @@ endif ()
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${POLLY_SOURCE_DIR}/cmake")
 
 SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+FIND_PACKAGE(Pluto)
+if(PLUTO_FOUND)
+  MESSAGE(STATUS "lib: ${PLUTO_INSTALL_DIR}")
+  set(PLUTO_LIBRARY ${PLUTO_LIBRARY} "-L${PLUTO_INSTALL_DIR}/lib/ -lisl")
+  set(POLLY_LINK_LIBS ${POLLY_LINK_LIBS} ${PLUTO_LIBRARY})
+endif(PLUTO_FOUND)
+
+if (PLUTO_FOUND)
+  INCLUDE_DIRECTORIES( ${PLUTO_INCLUDE_DIR} )
+endif(PLUTO_FOUND)
 
 option(POLLY_ENABLE_GPGPU_CODEGEN "Enable GPGPU code generation feature" OFF)
 if (POLLY_ENABLE_GPGPU_CODEGEN)
diff --git a/cmake/FindPluto.cmake b/cmake/FindPluto.cmake
new file mode 100644
index 0000000..2fe6fef
--- /dev/null
+++ b/cmake/FindPluto.cmake
@@ -0,0 +1,24 @@
+# Setting default installation directory in case PLUTO_INSTALL_DIR not specified
+IF(PLUTO_INSTALL_DIR)
+        SET(PLUTO_INSTALL_DIR ${PLUTO_INSTALL_DIR})
+ELSE(PLUTO_INSTALL_DIR)
+        SET(PLUTO_INSTALL_DIR "/usr/local")
+ENDIF(PLUTO_INSTALL_DIR)
+
+FIND_PATH(PLUTO_INCLUDE_DIR pluto/libpluto.h PATHS "${PLUTO_INSTALL_DIR}/include" NO_DEFAULT_PATH)
+FIND_LIBRARY(PLUTO_LIBRARY NAMES pluto PATHS "${PLUTO_INSTALL_DIR}/lib" NO_DEFAULT_PATH)
+
+IF (PLUTO_INCLUDE_DIR AND PLUTO_LIBRARY)
+  SET(PLUTO_FOUND TRUE)
+ENDIF (PLUTO_INCLUDE_DIR AND PLUTO_LIBRARY)
+
+IF (PLUTO_FOUND)
+  IF (NOT PLUTO_FIND_QUIETLY)
+    MESSAGE(STATUS "Found Pluto: ${PLUTO_LIBRARY}")
+    MESSAGE(STATUS "Found Pluto include: ${PLUTO_INCLUDE_DIR}")
+  ENDIF (NOT PLUTO_FIND_QUIETLY)
+ELSE (PLUTO_FOUND)
+  IF (PLUTO_FIND_REQUIRED)
+    MESSAGE(FATAL_ERROR "Could not find Pluto")
+  ENDIF (PLUTO_FIND_REQUIRED)
+ENDIF (PLUTO_FOUND)
diff --git a/include/polly/Config/config.h.cmake b/include/polly/Config/config.h.cmake
index 4abf8b9..f763f70 100644
--- a/include/polly/Config/config.h.cmake
+++ b/include/polly/Config/config.h.cmake
@@ -13,6 +13,7 @@
 #ifndef POLLY_CONFIG_H
 #define POLLY_CONFIG_H
 
+#cmakedefine PLUTO_FOUND
 #cmakedefine CUDALIB_FOUND
 #cmakedefine GPU_CODEGEN
 
diff --git a/include/polly/LinkAllPasses.h b/include/polly/LinkAllPasses.h
index 160e3c0..149c160 100644
--- a/include/polly/LinkAllPasses.h
+++ b/include/polly/LinkAllPasses.h
@@ -52,6 +52,9 @@ llvm::Pass *createCodeGenerationPass();
 llvm::Pass *createPPCGCodeGenerationPass(GPUArch Arch = GPUArch::NVPTX64,
                                          GPURuntime Runtime = GPURuntime::CUDA);
 #endif
+#ifdef PLUTO_FOUND
+llvm::Pass *createPlutoOptimizerPass();
+#endif
 llvm::Pass *createIslScheduleOptimizerPass();
 llvm::Pass *createFlattenSchedulePass();
 llvm::Pass *createDeLICMPass();
@@ -87,6 +90,9 @@ struct PollyForcePassLinking {
 #ifdef GPU_CODEGEN
     polly::createPPCGCodeGenerationPass();
 #endif
+#ifdef PLUTO_FOUND
+    llvm::Pass *createPlutoOptimizerPass();
+#endif
     polly::createIslScheduleOptimizerPass();
     polly::createFlattenSchedulePass();
     polly::createDeLICMPass();
@@ -108,6 +114,10 @@ void initializeCodeGenerationPass(llvm::PassRegistry &);
 #ifdef GPU_CODEGEN
 void initializePPCGCodeGenerationPass(llvm::PassRegistry &);
 #endif
+#ifdef PLUTO_FOUND
+void initializePlutoOptimizerPass(llvm::PassRegistry &);
+#endif
+
 void initializeIslScheduleOptimizerPass(llvm::PassRegistry &);
 void initializePollyCanonicalizePass(llvm::PassRegistry &);
 void initializeFlattenSchedulePass(llvm::PassRegistry &);
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index 57f1b9a..53347d6 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -1,4 +1,7 @@
 set(LLVM_NO_RTTI 1)
+if (PLUTO_FOUND)
+  set(POLLY_PLUTO_FILES Transform/Pluto.cpp)
+endif (PLUTO_FOUND)
 
 set(ISL_CODEGEN_FILES
     CodeGen/IslAst.cpp
@@ -60,6 +63,7 @@ add_library(PollyCore OBJECT
   Transform/FlattenAlgo.cpp
   Transform/DeLICM.cpp
   Transform/Simplify.cpp
+  ${POLLY_PLUTO_FILES}
   ${POLLY_HEADER_FILES}
   )
 set_target_properties(PollyCore PROPERTIES FOLDER "Polly")
diff --git a/lib/External/CMakeLists.txt b/lib/External/CMakeLists.txt
index 464c64b..9928673 100644
--- a/lib/External/CMakeLists.txt
+++ b/lib/External/CMakeLists.txt
@@ -20,12 +20,10 @@ if (POLLY_BUNDLED_ISL)
 
   message(STATUS "ISL version: ${ISL_GIT_HEAD_ID}")
 
-  # Enable small integer optimization and imath
-  set(USE_GMP_FOR_MP OFF)
-  set(USE_IMATH_FOR_MP ON)
-  set(USE_SMALL_INT_OPT ON)
-
-  # Determine compiler characteristics
+  set(USE_GMP_FOR_MP ON)
+  set(USE_IMATH_FOR_MP OFF)
+  set(USE_SMALL_INT_OPT OFF)
+# Determine compiler characteristics
   include(CheckCSourceCompiles)
 
   # Like check_c_source_compiles, but sets the result to either
@@ -175,8 +173,30 @@ if (POLLY_BUNDLED_ISL)
     ${ISL_SOURCE_DIR}
     )
 
+  set (GMP_FILES
+    isl/isl_gmp.c
+    isl/isl_val_gmp.c
+    )
+
+  set (IMATH_SIO_FILES
+    isl/isl_imath.c
+    isl/isl_int_sioimath.c
+    isl/isl_val_sioimath.c
+    isl/imath/gmp_compat.c
+    isl/imath/imath.c
+    isl/imath/imrat.c
+    )
+
+  set (IMATH_FILES
+    isl/isl_imath.c
+    isl/isl_val_imath.c
+    isl/imath/gmp_compat.c
+    isl/imath/imath.c
+    isl/imath/imrat.c
+    )
+
   # ISL files to compile
-  set (ISL_FILES
+  set (COMMON_ISL_FILES
     isl/basis_reduction_tab.c
     isl/isl_aff.c
     isl/isl_affine_hull.c
@@ -208,9 +228,7 @@ if (POLLY_BUNDLED_ISL)
     isl/isl_id_to_id.c
     isl/isl_id_to_pw_aff.c
     isl/isl_ilp.c
-    isl/isl_imath.c
     isl/isl_input.c
-    isl/isl_int_sioimath.c
     isl/isl_local.c
     isl/isl_local_space.c
     isl/isl_lp.c
@@ -249,16 +267,22 @@ if (POLLY_BUNDLED_ISL)
     isl/isl_transitive_closure.c
     isl/isl_union_map.c
     isl/isl_val.c
-    isl/isl_val_sioimath.c
     isl/isl_vec.c
     isl/isl_version.c
     isl/isl_vertices.c
     isl/print.c
-    isl/imath/gmp_compat.c
-    isl/imath/imath.c
-    isl/imath/imrat.c
     )
 
+  if (USE_IMATH_FOR_MP)
+    if (USE_SMALL_INT_OPT)
+      set(ISL_FILES ${COMMON_ISL_FILES} ${IMATH_SIO_FILES})
+    else ()
+      set(ISL_FILES ${COMMON_ISL_FILES} ${IMATH_FILES})
+    endif()
+  else ()
+    set(ISL_FILES ${COMMON_ISL_FILES} ${GMP_FILES})
+  endif ()
+
   add_polly_library(PollyISL
     ${ISL_FILES}
     )
@@ -355,6 +379,9 @@ if (MSVC)
 else ()
   if (POLLY_BUNDLED_ISL)
     set_target_properties(PollyISL polly-isl-test PROPERTIES COMPILE_FLAGS "-w")
+    if (USE_GMP_FOR_MP)
+      target_link_libraries(PollyISL "-lgmp")
+    endif ()
   endif (POLLY_BUNDLED_ISL)
   set_target_properties(PollyPPCG PROPERTIES COMPILE_FLAGS "-w")
 endif ()
diff --git a/lib/Support/RegisterPasses.cpp b/lib/Support/RegisterPasses.cpp
index 0376a06..28b0041 100644
--- a/lib/Support/RegisterPasses.cpp
+++ b/lib/Support/RegisterPasses.cpp
@@ -62,7 +62,13 @@ enum PassPositionChoice {
   POSITION_BEFORE_VECTORIZER
 };
 
-enum OptimizerChoice { OPTIMIZER_NONE, OPTIMIZER_ISL };
+enum OptimizerChoice {
+  OPTIMIZER_NONE,
+#ifdef PLUTO_FOUND
+  OPTIMIZER_PLUTO,
+#endif
+  OPTIMIZER_ISL
+};
 
 static cl::opt<PassPositionChoice> PassPosition(
     "polly-position", cl::desc("Where to run polly in the pass pipeline"),
@@ -78,6 +84,9 @@ static cl::opt<PassPositionChoice> PassPosition(
 static cl::opt<OptimizerChoice>
     Optimizer("polly-optimizer", cl::desc("Select the scheduling optimizer"),
               cl::values(clEnumValN(OPTIMIZER_NONE, "none", "No optimizer"),
+#ifdef PLUTO_FOUND
+                         clEnumValN(OPTIMIZER_PLUTO, "pluto", "The PLuTo scheduling optimizer"),
+#endif
                          clEnumValN(OPTIMIZER_ISL, "isl",
                                     "The isl scheduling optimizer")),
               cl::Hidden, cl::init(OPTIMIZER_ISL), cl::ZeroOrMore,
@@ -319,6 +328,11 @@ void registerPollyPasses(llvm::legacy::PassManagerBase &PM) {
     case OPTIMIZER_ISL:
       PM.add(polly::createIslScheduleOptimizerPass());
       break;
+#ifdef PLUTO_FOUND
+    case OPTIMIZER_PLUTO:
+      PM.add(polly::createPlutoOptimizerPass());
+      break;
+#endif
     }
   }
 
diff --git a/lib/Transform/Pluto.cpp b/lib/Transform/Pluto.cpp
new file mode 100644
index 0000000..5e5cf1d
--- /dev/null
+++ b/lib/Transform/Pluto.cpp
@@ -0,0 +1,283 @@
+//===- Pluto.cpp - Calculate an optimized schedule ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Use libpluto to optimize the schedule.
+//
+//===----------------------------------------------------------------------===//
+
+#include "polly/Config/config.h"
+
+#ifdef PLUTO_FOUND
+#include "polly/CodeGen/CodeGeneration.h"
+#include "polly/DependenceInfo.h"
+#include "polly/LinkAllPasses.h"
+#include "polly/Options.h"
+#include "polly/ScopInfo.h"
+#include "polly/Support/GICHelper.h"
+#include "llvm/Support/Debug.h"
+
+#include "pluto/libpluto.h"
+#include "isl/map.h"
+
+using namespace llvm;
+using namespace polly;
+
+#define DEBUG_TYPE "polly-opt-pluto"
+
+static cl::opt<bool> EnableTiling("polly-pluto-tile", cl::desc("Enable tiling"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> EnableIntraTiling("polly-pluto-intratileopt",
+		cl::desc("Enable intratiling"),
+		cl::Hidden, cl::init(true),
+		cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoDebug("polly-pluto-debug",
+		cl::desc("Enable pluto debug"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoMoreDebug("polly-pluto-moredebug",
+		cl::desc("Enable more pluto debugging"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoSilent("polly-pluto-silent",
+                cl::desc("Disables silence"),
+                cl::Hidden, cl::init(true), cl::ZeroOrMore,
+                cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoParallel("polly-pluto-parallel",
+		cl::desc("Enable pluto parallel transforms"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<std::string> FusionStrategy(
+    "polly-pluto-fusion", cl::desc("The fusion strategy to choose (min/max/smart)"),
+    cl::Hidden, cl::init("smart"), cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool>
+PlutoInnerParallel("polly-pluto-innerpara",
+		cl::desc("Enable inner parallelism instead of piped."),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool>
+PlutoIdentity("polly-pluto-identity",
+		cl::desc("Enable pluto identity transformation"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoUnroll("polly-pluto-unroll",
+		cl::desc("Enable pluto unrolling"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoRar("polly-pluto-rar",
+		cl::desc("Enable pluto rar deps"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoParaPipe("polly-pluto-multipipe",
+		cl::desc("Enable multipipe parallelism"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoL2Tile("polly-pluto-l2tile",
+		cl::desc("Enable L2 tiling"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoPollyUnroll("polly-pluto-pollyunroll",
+		cl::desc("Enable pluto polly unrolling"),
+		cl::Hidden, cl::init(false),
+		cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool>
+PlutoIslDep("polly-pluto-isldep",
+		cl::desc("Enable pluto isl dependency scanning"), cl::Hidden,
+		cl::init(false), cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoIslDepCompact(
+		"polly-pluto-isldepcom", cl::desc("Enable pluto isl dependency compaction"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore, cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoIslSolve("polly-pluto-islsolve",
+		cl::desc("Enable pluto isl solver"),
+		cl::Hidden, cl::init(false), cl::ZeroOrMore,
+		cl::cat(PollyCategory));
+
+static cl::opt<bool> PlutoLastWriter("polly-pluto-lastwriter",
+		cl::desc("Enable pluto lastwriter"),
+		cl::Hidden, cl::init(false),
+		cl::ZeroOrMore, cl::cat(PollyCategory));
+
+namespace {
+	static std::string convertInt(int number) {
+		if (number == 0)
+			return "0";
+		std::string temp = "";
+		std::string returnvalue = "";
+		while (number > 0) {
+			temp += number % 10 + 48;
+			number /= 10;
+		}
+		for (unsigned i = 0; i < temp.length(); i++)
+			returnvalue += temp[temp.length() - i - 1];
+		return returnvalue;
+	}
+
+	class PlutoOptimizer : public ScopPass {
+		public:
+			static char ID;
+			explicit PlutoOptimizer() : ScopPass(ID) { }
+
+			virtual bool runOnScop(Scop &S);
+			void printScop(llvm::raw_ostream &OS) const;
+			void getAnalysisUsage(AnalysisUsage &AU) const;
+	};
+}
+
+char PlutoOptimizer::ID = 0;
+
+bool PlutoOptimizer::runOnScop(Scop &S) {
+	DEBUG(dbgs() << "Optimizing using pluto\n");
+
+	isl_union_map *Schedule;
+
+	if (S.getSize() == 0) {
+		S.markAsOptimized();
+		return false;
+	}
+
+	const Dependences &D = getAnalysis<DependenceInfo>().getDependences(Dependences::AL_Statement);
+	if(!D.hasValidDependences())
+		return false;
+
+	int DependencesKinds = Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
+
+	isl_union_map *Deps = D.getDependences(DependencesKinds);
+
+	isl_union_set *Domain = S.getDomains();
+	if(!Domain)
+		return false;
+
+	isl_union_map *ToPlutoNames = isl_union_map_empty(S.getParamSpace());
+
+	// converting the statement names to the names pluto can understand
+	int counter = 0;
+	for (ScopStmt &Stmt : S) {
+		std::string Name = "S_" + convertInt(counter);
+		isl_map *Identity = isl_map_identity(isl_space_map_from_domain_and_range(
+					Stmt.getDomainSpace(), Stmt.getDomainSpace()));
+		Identity = isl_map_set_tuple_name(Identity, isl_dim_out, Name.c_str());
+		ToPlutoNames = isl_union_map_add_map(ToPlutoNames, Identity);
+		counter++;
+	}
+
+	isl_union_map *Read, *Write;
+	isl_space *Space = S.getParamSpace();
+	Read = isl_union_map_empty(isl_space_copy(Space));
+	Write = isl_union_map_empty(isl_space_copy(Space));
+
+	for (ScopStmt &Stmt : S) {
+	    for (MemoryAccess *MA : Stmt) {
+		isl_set *domcp = Stmt.getDomain();
+		isl_map *accdom = MA->getAccessRelation();
+
+		accdom = isl_map_intersect_domain(accdom, domcp);
+
+		if (MA->isRead())
+		    Read = isl_union_map_add_map(Read, accdom);
+		else
+		    Write = isl_union_map_add_map(Write, accdom);
+	    }
+	}
+
+	Deps = isl_union_map_apply_domain(Deps, isl_union_map_copy(ToPlutoNames));
+	Deps = isl_union_map_apply_range(Deps, isl_union_map_copy(ToPlutoNames));
+	Domain = isl_union_set_apply(Domain, isl_union_map_copy(ToPlutoNames));
+
+	Read = isl_union_map_apply_domain(Read, isl_union_map_copy(ToPlutoNames));
+	Write = isl_union_map_apply_domain(Write, isl_union_map_copy(ToPlutoNames));
+
+	// creating the options
+	PlutoOptions *Options = pluto_options_alloc();
+
+	Options->debug = PlutoDebug;
+	Options->identity = PlutoIdentity;
+	Options->innerpar = PlutoInnerParallel;
+	Options->intratileopt = EnableIntraTiling;
+	Options->isldep = PlutoIslDep;
+	Options->islsolve = PlutoIslSolve;
+	Options->l2tile = PlutoL2Tile;
+	Options->lastwriter = PlutoLastWriter;
+	Options->moredebug = PlutoMoreDebug;
+	Options->parallel = PlutoParallel;
+	Options->polyunroll = PlutoPollyUnroll;
+	Options->rar = PlutoRar;
+	Options->tile = EnableTiling;
+	Options->unroll = PlutoUnroll;
+	Options->silent = PlutoSilent;
+	Options->isldepaccesswise = 0;
+
+	if (FusionStrategy == "min")
+		Options->fuse = NO_FUSE;
+	else if (FusionStrategy == "max")
+		Options->fuse = MAXIMAL_FUSE;
+	else
+		Options->fuse = SMART_FUSE;
+
+	// call to pluto interface
+	Schedule = pluto_schedule(Domain, Deps, Read, Write, Options);
+
+	if(!Schedule)
+		return false;
+
+	Schedule = isl_union_map_apply_domain(Schedule, isl_union_map_reverse(ToPlutoNames));
+
+	DEBUG(dbgs() << "NEW Schedule:\n");
+	DEBUG(dbgs() << stringFromIslObj(Schedule) << "\n");
+
+	// updating the schedule
+	S.setSchedule(Schedule);
+	S.markAsOptimized();
+
+	/* Freeing resources or objects*/
+	isl_union_set_free(Domain);
+	isl_union_map_free(Deps);
+
+	isl_union_map_free(Read);
+	isl_union_map_free(Write);
+	isl_space_free(Space);
+
+	pluto_options_free(Options);
+
+	return false;
+}
+
+void PlutoOptimizer::printScop(raw_ostream &OS) const { }
+
+void PlutoOptimizer::getAnalysisUsage(AnalysisUsage &AU) const {
+	ScopPass::getAnalysisUsage(AU);
+	AU.addRequired<DependenceInfo>();
+}
+
+Pass *polly::createPlutoOptimizerPass() { return new PlutoOptimizer(); }
+
+INITIALIZE_PASS_BEGIN(PlutoOptimizer, "polly-opt-pluto",
+		"Polly - Optimize schedule of SCoP (Pluto)", false,
+		false);
+INITIALIZE_PASS_DEPENDENCY(DependenceInfo);
+INITIALIZE_PASS_DEPENDENCY(ScopInfoRegionPass);
+INITIALIZE_PASS_END(PlutoOptimizer, "polly-opt-pluto",
+		"Polly - Optimize schedule of SCoP (Pluto)", false, false)
+
+static RegisterPass<PlutoOptimizer> X("polly-opt-pluto", "The PLuTo Optimizer", false, false);
+#endif // PLUTO_FOUND
-- 
1.9.1

